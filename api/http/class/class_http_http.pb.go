// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.2
// - protoc             v4.25.0
// source: http/class/class_http.proto

package class

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationClassCreateClass = "/http.class.Class/CreateClass"
const OperationClassGetClassByName = "/http.class.Class/GetClassByName"

type ClassHTTPServer interface {
	// CreateClass 创建班级
	CreateClass(context.Context, *CreateClassRequest) (*CreateClassReply, error)
	// GetClassByName 根据名字获取班级信息
	GetClassByName(context.Context, *GetClassByNameRequest) (*GetClassByNameReply, error)
}

func RegisterClassHTTPServer(s *http.Server, srv ClassHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/class/create", _Class_CreateClass0_HTTP_Handler(srv))
	r.POST("/v1/class/get_by_name", _Class_GetClassByName0_HTTP_Handler(srv))
}

func _Class_CreateClass0_HTTP_Handler(srv ClassHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateClassRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClassCreateClass)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateClass(ctx, req.(*CreateClassRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateClassReply)
		return ctx.Result(200, reply)
	}
}

func _Class_GetClassByName0_HTTP_Handler(srv ClassHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetClassByNameRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClassGetClassByName)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetClassByName(ctx, req.(*GetClassByNameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetClassByNameReply)
		return ctx.Result(200, reply)
	}
}

type ClassHTTPClient interface {
	CreateClass(ctx context.Context, req *CreateClassRequest, opts ...http.CallOption) (rsp *CreateClassReply, err error)
	GetClassByName(ctx context.Context, req *GetClassByNameRequest, opts ...http.CallOption) (rsp *GetClassByNameReply, err error)
}

type ClassHTTPClientImpl struct {
	cc *http.Client
}

func NewClassHTTPClient(client *http.Client) ClassHTTPClient {
	return &ClassHTTPClientImpl{client}
}

func (c *ClassHTTPClientImpl) CreateClass(ctx context.Context, in *CreateClassRequest, opts ...http.CallOption) (*CreateClassReply, error) {
	var out CreateClassReply
	pattern := "/v1/class/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationClassCreateClass))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClassHTTPClientImpl) GetClassByName(ctx context.Context, in *GetClassByNameRequest, opts ...http.CallOption) (*GetClassByNameReply, error) {
	var out GetClassByNameReply
	pattern := "/v1/class/get_by_name"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationClassGetClassByName))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
